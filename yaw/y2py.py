#!/usr/bin/env python3
"""
yawc: Yaw Compiler - Converts .yaw files to Python

Usage:
    python yawc.py input.yaw [-o output.py]
    
The compiler transforms yaw REPL syntax into executable Python code.
"""

import sys
import argparse
import re
from pathlib import Path


class YawCompiler:
    """Compiler for yaw quantum programming language.
    
    Converts yaw REPL syntax into Python code that imports and uses
    the yaw_prototype module.
    """
    
    def __init__(self):
        """Initialize the compiler."""
        self.imports = set()
        self.imports.add("from yaw_prototype import *")
        self.imports.add("from sympy import sqrt, exp, pi")
        self.imports.add("from sympy import I as sympy_I  # Imaginary unit (use sparingly)")
        self.preamble = []
        self.body = []
        self.has_algebra = False
        self.indent_level = 0
        self.in_multiline = False
        self.multiline_buffer = []
        
    def compile_file(self, input_path: str, output_path: str = None):
        """Compile a .yaw file to Python.
        
        Args:
            input_path: Path to input .yaw file
            output_path: Path to output .py file (optional)
            
        Returns:
            Generated Python code as string
        """
        # Read input file
        with open(input_path, 'r') as f:
            yaw_code = f.read()
        
        # Compile
        python_code = self.compile(yaw_code)
        
        # Write output if path specified
        if output_path:
            with open(output_path, 'w') as f:
                f.write(python_code)
            print(f"Compiled {input_path} -> {output_path}")
        
        return python_code
    
    def compile(self, yaw_code: str) -> str:
        """Compile yaw code to Python.
        
        Args:
            yaw_code: String containing yaw REPL syntax
            
        Returns:
            Python code as string
        """
        lines = yaw_code.split('\n')
        
        for line in lines:
            self._compile_line(line)
        
        # Flush any remaining multiline buffer
        if self.multiline_buffer:
            self._flush_multiline()
        
        # Build output
        output = []
        output.append('"""')
        output.append('Generated by yawc (Yaw Compiler)')
        output.append('"""')
        output.append('')
        
        # Add imports
        for imp in sorted(self.imports):
            output.append(imp)
        output.append('')
        
        # Add preamble (context setup, etc.)
        if self.preamble:
            output.extend(self.preamble)
            output.append('')
        
        # Add main code
        output.extend(self.body)
        
        return '\n'.join(output)
    
    def _compile_line(self, line: str):
        """Compile a single line of yaw code.
        
        Args:
            line: Single line of yaw code
        """
        stripped = line.strip()
        
        # Skip empty lines and comments
        if not stripped or stripped.startswith('#'):
            if self.in_multiline:
                self.multiline_buffer.append(line)
            else:
                self.body.append(line)
            return
        
        # Check for multiline statements
        if self._is_multiline_start(stripped) or self.in_multiline:
            self.multiline_buffer.append(line)
            self.in_multiline = True
            
            # Check if multiline is complete
            if self._is_multiline_complete():
                self._flush_multiline()
            return
        
        # Handle special commands
        if self._handle_command(stripped):
            return
        
        # Transform line and add to body
        transformed = self._transform_line(line)
        self.body.append(transformed)
    
    def _is_multiline_start(self, line: str) -> bool:
        """Check if line starts a multiline statement."""
        keywords = ['for', 'while', 'if', 'def', 'class', 'with', 'try']
        return any(line.startswith(kw + ' ') or line.startswith(kw + ':') 
                   for kw in keywords)
    
    def _is_multiline_complete(self) -> bool:
        """Check if multiline statement is complete."""
        if not self.multiline_buffer:
            return False
        
        # Check if last non-empty line is not indented
        for line in reversed(self.multiline_buffer):
            if line.strip():
                # If it's a continuation keyword, not complete
                if any(line.strip().startswith(kw) 
                       for kw in ['else:', 'elif', 'except:', 'finally:']):
                    return False
                # If it starts with whitespace, not complete
                if line and line[0] in (' ', '\t'):
                    return False
                # Otherwise, this is the last line and it's not indented
                return True
        
        return True
    
    def _flush_multiline(self):
        """Process and add multiline buffer to body."""
        # Transform all lines in buffer
        for line in self.multiline_buffer:
            transformed = self._transform_line(line)
            self.body.append(transformed)
        
        self.multiline_buffer = []
        self.in_multiline = False
    
    def _handle_command(self, line: str) -> bool:
        """Handle special yaw commands.
        
        Args:
            line: Stripped line
            
        Returns:
            True if line was a command, False otherwise
        """
        # Skip REPL-only commands in compiled code
        if line in ['help', 'credits', 'puzzle', 'exit', 'quit']:
            self.body.append(f"# Skipped REPL command: {line}")
            return True
        
        if line == 'algebra':
            self.body.append("# Show algebra")
            self.body.append("if 'current_algebra' in dir():")
            self.body.append("    print(current_algebra)")
            return True
        
        if line == 'vars':
            self.body.append("# List variables")
            self.body.append("print([v for v in dir() if not v.startswith('_')])")
            return True
        
        if line.startswith('verbose'):
            if 'on' in line:
                self.body.append("verbose = True")
            elif 'off' in line:
                self.body.append("verbose = False")
            return True
        
        return False
    
    def _transform_line(self, line: str) -> str:
        """Transform yaw syntax to Python.
        
        Args:
            line: Line with potential yaw syntax
            
        Returns:
            Line with Python syntax
        """
        # Preserve indentation
        indent = len(line) - len(line.lstrip())
        content = line[indent:]
        
        # Transform special syntax in order
        # Note: list comprehensions must be checked before subscripts are simplified
        content = self._transform_algebra_def(content)
        content = self._transform_local_context(content)
        content = self._transform_commutators(content)
        content = self._transform_list_comp_assignment(content)  # Before subscripts
        content = self._transform_subscripts(content)
        
        return ' ' * indent + content
    
    def _transform_algebra_def(self, line: str) -> str:
        """Transform algebra definition syntax.
        
        Transforms: $alg = <X, Z | herm, unit, anti>
        Into: current_algebra = Algebra(gens=['X', 'Z'], rels=['herm', 'unit', 'anti'])
              X = current_algebra.X
              Z = current_algebra.Z
              I = current_algebra.I  # Identity operator
        """
        # Pattern: $alg = <gens | rels>
        match = re.match(r'\$alg\s*=\s*<([^|]+)\|([^>]+)>', line)
        if match:
            gens_str = match.group(1).strip()
            rels_str = match.group(2).strip()
            
            # Parse generators
            gens = [g.strip() for g in gens_str.split(',')]
            gens_list = ', '.join(f"'{g}'" for g in gens)
            
            # Parse relations
            rels = [r.strip() for r in rels_str.split(',')]
            rels_list = ', '.join(f"'{r}'" for r in rels)
            
            # Generate code
            result = []
            result.append(f"current_algebra = Algebra(gens=[{gens_list}], rels=[{rels_list}])")
            
            # Add generator assignments
            for gen in gens:
                result.append(f"{gen} = current_algebra.{gen}")
            
            # Always add identity operator
            result.append("I = current_algebra.I")
            
            self.has_algebra = True
            
            # Return as multiple lines joined
            return '\n'.join(result)
        
        return line
    
    def _transform_local_context(self, line: str) -> str:
        """Transform local context syntax.
        
        Transforms: expr ! <A, B | rels>
        Into: (expr).normalize(algebra=Algebra(gens=['A', 'B'], rels=[...]))
        
        Transforms: expr ! pow(3), herm
        Into: (expr).normalize(extra_rels=['pow(3)', 'herm'])
        """
        # Check for ! operator
        if '!' not in line:
            return line
        
        parts = line.split('!')
        if len(parts) != 2:
            return line
        
        expr = parts[0].strip()
        context = parts[1].strip()
        
        # Full algebra spec: <gens | rels>
        match = re.match(r'<([^|]+)\|([^>]+)>', context)
        if match:
            gens_str = match.group(1).strip()
            rels_str = match.group(2).strip()
            
            gens = [g.strip() for g in gens_str.split(',')]
            rels = [r.strip() for r in rels_str.split(',')]
            
            gens_list = ', '.join(f"'{g}'" for g in gens)
            rels_list = ', '.join(f"'{r}'" for r in rels)
            
            return f"({expr}).normalize(algebra=Algebra(gens=[{gens_list}], rels=[{rels_list}]))"
        
        # Just relations
        rels = [r.strip() for r in context.split(',')]
        rels_list = ', '.join(f"'{r}'" for r in rels)
        return f"({expr}).normalize(extra_rels=[{rels_list}])"
    
    def _transform_commutators(self, line: str) -> str:
        """Transform commutator syntax.
        
        Transforms: [[A, B]] -> comm(A, B)
        Transforms: {{A, B}} -> acomm(A, B)
        """
        # Double brackets for commutator
        line = re.sub(r'\[\[(.*?)\]\]', r'comm(\1)', line)
        
        # Double braces for anticommutator
        line = re.sub(r'\{\{(.*?)\}\}', r'acomm(\1)', line)
        
        return line
    
    def _transform_subscripts(self, line: str) -> str:
        """Transform subscript notation.
        
        Note: This is a simple transformation that assumes subscripts
        are either numeric or simple variable references.
        
        Transforms: P_{k} -> P_k (Python variable)
        """
        # Pattern: var_{expr} -> var_expr
        # For compilation, we just remove the braces
        line = re.sub(r'(\w+)_{([^}]+)}', r'\1_\2', line)
        
        return line
    
    def _transform_list_comp_assignment(self, line: str) -> str:
        """Transform list comprehension with assignment.
        
        Transforms:
            [P_{k} = proj(Z, k) for k in range(2)]
        Into:
            # Generate P_0, P_1
            for k in range(2):
                globals()[f'P_{k}'] = proj(Z, k)
        
        Also handles:
            projectors = [P_{k} = proj(Z, k) for k in range(2)]
            [P_k = proj(Z, k) for k in range(2)]  # After subscript transform
        """
        # Pattern 1: With left-hand assignment: var = [P_{k} = value for...]
        pattern_with_assignment = r'(\w+)\s*=\s*\[(\w+)_{(\w+)}\s*=\s*([^f]+?)\s+for\s+(\w+)\s+in\s+([^\]]+)\]'
        match = re.search(pattern_with_assignment, line)
        
        if match:
            result_var = match.group(1)     # e.g., "projectors"
            var_base = match.group(2)       # e.g., "P"
            subscript_var = match.group(3)  # e.g., "k"
            value_expr = match.group(4).strip()  # e.g., "proj(Z, k)"
            loop_var = match.group(5)       # e.g., "k"
            iterable = match.group(6).strip()  # e.g., "range(2)"
            
            # Generate for loop with proper f-string interpolation
            result = []
            result.append(f"# Generate {var_base}_{{i}} for i in {iterable}")
            result.append(f"for {loop_var} in {iterable}:")
            result.append(f"    globals()[f'{var_base}_{{{{{loop_var}}}}}'] = {value_expr}")
            
            return '\n'.join(result)
        
        # Pattern 2: Bare list comprehension: [P_{k} = value for...]
        pattern_bare = r'^\s*\[(\w+)_{(\w+)}\s*=\s*([^f]+?)\s+for\s+(\w+)\s+in\s+([^\]]+)\]\s*$'
        match = re.search(pattern_bare, line)
        
        if match:
            var_base = match.group(1)       # e.g., "P"
            subscript_var = match.group(2)  # e.g., "k"
            value_expr = match.group(3).strip()  # e.g., "proj(Z, k)"
            loop_var = match.group(4)       # e.g., "k"
            iterable = match.group(5).strip()  # e.g., "range(2)"
            
            # Generate for loop with proper f-string interpolation
            result = []
            result.append(f"# Generate {var_base}_{{i}} for i in {iterable}")
            result.append(f"for {loop_var} in {iterable}:")
            result.append(f"    globals()[f'{var_base}_{{{{{loop_var}}}}}'] = {value_expr}")
            
            return '\n'.join(result)
        
        # Pattern 3: After subscript transform - with assignment: var = [P_k = value for...]
        pattern_plain_with_assignment = r'(\w+)\s*=\s*\[(\w+)_(\w+)\s*=\s*([^f]+?)\s+for\s+(\w+)\s+in\s+([^\]]+)\]'
        match = re.search(pattern_plain_with_assignment, line)
        
        if match:
            result_var = match.group(1)     # e.g., "projectors"
            var_base = match.group(2)       # e.g., "P"
            subscript_var = match.group(3)  # e.g., "k"
            value_expr = match.group(4).strip()  # e.g., "proj(Z, k)"
            loop_var = match.group(5)       # e.g., "k"
            iterable = match.group(6).strip()  # e.g., "range(2)"
            
            # Generate for loop with proper f-string interpolation
            result = []
            result.append(f"# Generate {var_base}_{{i}} for i in {iterable}")
            result.append(f"for {loop_var} in {iterable}:")
            result.append(f"    globals()[f'{var_base}_{{{{{loop_var}}}}}'] = {value_expr}")
            
            return '\n'.join(result)
        
        # Pattern 4: Bare after subscript transform: [P_k = value for...]
        pattern_bare_plain = r'^\s*\[(\w+)_(\w+)\s*=\s*([^f]+?)\s+for\s+(\w+)\s+in\s+([^\]]+)\]\s*$'
        match = re.search(pattern_bare_plain, line)
        
        if match:
            var_base = match.group(1)       # e.g., "P"
            subscript_var = match.group(2)  # e.g., "k"
            value_expr = match.group(3).strip()  # e.g., "proj(Z, k)"
            loop_var = match.group(4)       # e.g., "k"
            iterable = match.group(5).strip()  # e.g., "range(2)"
            
            # Generate for loop with proper f-string interpolation
            result = []
            result.append(f"# Generate {var_base}_{{i}} for i in {iterable}")
            result.append(f"for {loop_var} in {iterable}:")
            result.append(f"    globals()[f'{var_base}_{{{{{loop_var}}}}}'] = {value_expr}")
            
            return '\n'.join(result)
        
        return line
    
    def _add_preamble(self):
        """Add standard preamble for compiled code."""
        if not self.preamble:
            self.preamble.append("# Initialize context")
            self.preamble.append("context = Context()")
            self.preamble.append("verbose = False")


def main():
    """Main entry point for compiler."""
    parser = argparse.ArgumentParser(
        description='Compile yaw quantum programs to Python',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python yawc.py program.yaw              # Compile and print to stdout
  python yawc.py program.yaw -o prog.py   # Compile to file
  python yawc.py program.yaw -o - | python  # Compile and run
        """
    )
    
    parser.add_argument('input', help='Input .yaw file')
    parser.add_argument('-o', '--output', help='Output .py file (default: stdout)')
    
    args = parser.parse_args()
    
    # Compile
    compiler = YawCompiler()
    python_code = compiler.compile_file(args.input, args.output)
    
    # Print to stdout if no output file
    if not args.output:
        print(python_code)


if __name__ == '__main__':
    main()
