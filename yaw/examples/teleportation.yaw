# teleportation.yaw
# Teleport with algebra!

$alg = <X, Z | herm, unit, anti, pow(2)>              # define the Pauli algebra

H = (X + Z) / sqrt(2)                                 # the Hadamard gate
CNOT = ctrl(Z, [I, X])                                # CX, aka CNOT
psi0 = char(Z, 0)                                     # invoke ⟨0|⋅|0⟩ state

U_A = H                                               # unitary encoding Alice's state; you can change it!

# === Protocol Setup ===

psi_alice = U_A << psi0                              # Alice's prepares state |ψ_A⟩ = U_A|0⟩
psi00 = psi0 @ psi0                                  # tensor product of states |00⟩
epr = CNOT*(H @ I) << psi00                          # create EPR state |EPR⟩ = (|00⟩ + |11⟩)/√2

total = psi_alice @ epr                              # form total three-qubit state |EPR⟩|ψ_A⟩

# === Bell measurement ===

[proj_{i} = proj(Z, i) for i in range(2)]            # define projectors |i⟩⟨i|
[[eproj_{i}{j} = CNOT*(H @ I)
...   >> proj_{i} @ proj_{j}
...   for i in range(2)] for j in range(2)]]         # define Bell measurement projectors, aka eproj = EPR + proj
eprojs = [eproj_{0}{0} @ I, eproj_{0}{1} @ I,
...       eproj_{1}{0} @ I, eproj_{1}{1} @ I]        # list all the eproj and tensor with identity on Bob's system

measure = stMeasure(eprojs, total)                   # Alice measures in Bell basis
measured_state, index = measure()                    # Alice gets measurement index (from 0-3) she sends to Bob

# === Bob's correction ===

a, b = int(bin(index)[2], int(bin(index)[3])         # Bob turns the Alice's measured outcome into two bits
bob_correct = Z**b * X**a                            # Bob defines a correction operator
bob_final = I @ I @ bob_correct << measured_state    # Bob applies correction operator